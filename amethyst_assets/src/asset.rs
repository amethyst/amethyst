use failure::{Fail, ResultExt};
use std::sync::Arc;

use amethyst_core::specs::storage::UnprotectedStorage;

use {Error, ErrorKind, Handle, Reload, SingleFile, Source};

/// One of the three core traits of this crate.
///
/// You want to implement this for every type of asset like
///
/// * `Mesh`
/// * `Texture`
/// * `Terrain`
///
/// and so on. Now, an asset may be available in different formats.
/// That's why we have the `Data` associated type here. You can specify
/// an intermediate format here, like the vertex data for a mesh or the samples
/// for audio data.
///
/// This data is then generated by the `Format` trait.
pub trait Asset: Send + Sync + 'static {
    /// An identifier for this asset used for debugging.
    const NAME: &'static str;

    /// The `Data` type the asset can be created from.
    type Data: Send + Sync + 'static;

    /// The ECS storage type to be used. You'll want to use `VecStorage` in most cases.
    type HandleStorage: UnprotectedStorage<Handle<Self>> + Send + Sync;
}

/// A format, providing a conversion from bytes to asset data, which is then
/// in turn accepted by `Asset::from_data`. Examples for formats are
/// `Png`, `Obj` and `Wave`.
pub trait Format<A: Asset>: Send + 'static {
    /// A unique identifier for this format.
    const NAME: &'static str;
    /// Options specific to the format, which are passed to `import`.
    /// E.g. for textures this would be stuff like mipmap levels and
    /// sampler info.
    type Options: Send + 'static;

    /// The import operation may fail with this associated Error type.
    ///
    /// If your import cannot fail consider using the never type `!` TODO when
    /// it becomes stable.
    type Error: Fail;

    /// Reads the given bytes and produces asset data.
    ///
    /// # Reload
    ///
    /// The reload structure has metadata which allows the asset management
    /// to reload assets if necessary (for hot reloading).
    /// You should only create this if `create_reload` is `true`.
    /// Also, the parameter is just a request, which means you can also return `None`.
    fn import(
        &self,
        name: String,
        source: Arc<Source>,
        options: Self::Options,
        create_reload: bool,
    ) -> Result<FormatValue<A>, Self::Error>;
}

/// The `Ok` return value of `Format::import` for a given asset type `A`.
pub struct FormatValue<A: Asset> {
    /// The format data.
    pub data: A::Data,
    /// An optional reload structure
    pub reload: Option<Box<Reload<A>>>,
}

impl<A: Asset> FormatValue<A> {
    /// Creates a `FormatValue` from only the data (setting `reload` to `None`).
    pub fn data(data: A::Data) -> Self {
        FormatValue { data, reload: None }
    }
}

/// This is a simplified version of `Format`, which doesn't give you as much freedom,
/// but in return is simpler to implement.
/// All `SimpleFormat` types automatically implement `Format`.
/// This format assumes that the asset name is the full path and the asset is only
/// contained in one file.
pub trait SimpleFormat<A: Asset> {
    /// A unique identifier for this format.
    const NAME: &'static str;

    /// Options specific to the format, which are passed to `import`.
    /// E.g. for textures this would be stuff like mipmap levels and
    /// sampler info.
    type Options: Clone + Send + Sync + 'static;

    /// The import operation may fail with this associated Error type.
    ///
    /// If your import cannot fail consider using the never type `!` TODO when
    /// it becomes stable.
    type Error: Fail;

    /// Produces asset data from given bytes.
    fn import(&self, bytes: Vec<u8>, options: Self::Options) -> Result<A::Data, Self::Error>;
}

impl<A, T> Format<A> for T
where
    A: Asset,
    T: SimpleFormat<A> + Clone + Send + Sync + 'static,
{
    const NAME: &'static str = T::NAME;
    type Options = T::Options;
    type Error = Error;

    fn import(
        &self,
        name: String,
        source: Arc<Source>,
        options: Self::Options,
        create_reload: bool,
    ) -> Result<FormatValue<A>, Self::Error> {
        #[cfg(feature = "profiler")]
        profile_scope!("import_asset");
        if create_reload {
            let (b, m) = source.load_with_metadata(&name)?;
            let data =
                T::import(&self, b, options.clone()).context(ErrorKind::ImportAssetFromBytes {
                    name: name.clone(),
                    asset_type: Self::NAME,
                })?;
            let reload = SingleFile::new(self.clone(), m, options, name, source);
            let reload = Some(Box::new(reload) as Box<Reload<A>>);
            Ok(FormatValue { data, reload })
        } else {
            let b = source.load(&name).context(ErrorKind::FetchAssetFromSource(name.clone()))?;
            let data = T::import(&self, b, options).context(ErrorKind::ImportAssetFromBytes {
                name: name.clone(),
                asset_type: Self::NAME,
            })?;

            Ok(FormatValue::data(data))
        }
    }
}
